# AI Methodology & Workflow

## Overview
This document outlines the "Agentic Workflow" used to build this application. The development process was a collaboration between human decision-making and AI assistance, leveraging specific tools for distinct stages of the engineering lifecycle.

## The AI Stack

I utilized a dual-agent approach to simulate a full engineering team environment:

* **Google Gemini 3.0** – **Senior Architect / Tech Lead**: Used for high-level decision making, architectural planning, code review, and solving complex performance bottlenecks (e.g., MVT highlighting, aggregation logic).
* **Cursor** – **Pair Programmer**: Used for implementation execution, writing boilerplate, refactoring file structures, and applying the architectural patterns generated by the Lead.

---

## Methodology: The "Architect-Builder" Loop

My workflow followed a strict iterative loop to ensure code quality and avoid "hallucinations":

### 1. Context Injection & Rule Definition
**Goal:** Convert requirements into Cursor rules to achieve a consistent development environment.
* **System Prompt used:**
    ```text
    Act as a Senior QA Engineer. Analyze the project requirements and generate Cursor rules structured by their context. Rules should include both functional and non-functional requirements, implementation constraints, and recommendations.
    ```
* **Sub-prompts used (in Cursor):** Adjust rules, technology constraints, and file structure definitions.

### 2. Requirement Decomposition
**Goal:** Decompose requirements into logical, iterative phases.
* **System Prompt used:**
    ```text
    Here are the requirements for the assignment [Front-End Engineer assignment.pdf].

    I need to build this using React, TypeScript, and deck.gl.
    Can you analyze the PDF and decompose the requirements into logical, iterative development phases?
    I want a step-by-step plan that I can follow to implement the app, starting from the basic map setup to the advanced widgets.
    ```
* **Sub-prompts used (in Cursor):** Adjust phases, omit unnecessary complexity, and provide specific implementation details.

### 3. Core Map Implementation
**Goal:** Implement base Map functionality, configure API keys, connect layers, and render base data.
* **System Prompt used:**
    ```text
    Act as a Senior React Engineer & WebGL Specialist.

    **Objective:**
    Execute Phase 1 of the implementation plan: "Base Map & Data Rendering".

    **Context:**
    We have a React + TypeScript project set up. We need to initialize the mapping engine and connect to the CARTO Data Warehouse.

    **Task:**
    1.  **Map Component (`src/features/Map/Map.tsx`):**
        -   Initialize the `Deck` class with a `MapLibre` basemap integration.
        -   Ensure proper view state synchronization between Deck.gl and the basemap.
        -   Read the API Access Token from `import.meta.env.VITE_API_ACCESS_TOKEN`.

    2.  **Layer Management (`src/hooks/useCartoLayers.ts`):**
        -   Create a custom hook to manage layer instantiation.
        -   **Retail Layer:** Configure a `VectorTileLayer` using the `vectorTableSource` for the table `carto-demo-data.demo_tables.retail_stores`.
        -   **Sociodemographics Layer:** Configure a `VectorTileLayer` using the `vectorTilesetSource` for the tileset `carto-demo-data.demo_tilesets.sociodemographics_usa_blockgroup`.
        -   **Ordering:** Ensure Points (Retail) are rendered *above* Polygons (Socio).

    **Output:**
    Provide the complete, strictly typed TypeScript code for `Map.tsx` and `useCartoLayers.ts`.
    ```
* **Sub-prompts used (in Cursor):** State decomposition improvements, handling public/private state keys, selector adjustments.

### 4. UI/UX & Styling Configuration
**Goal:** Allow users to configure layers styles and settings efficiently.
* **System Prompt used:**
    ```text
    Act as a Senior Frontend Engineer.

    **Objective:**
    Execute Phase 2 of the plan: "Layer Configuration & Styling UI".

    **Context:**
    The map is rendering data, but the styling is hardcoded. We need a reactive UI to let users modify layer properties in real-time.

    **Task:**
    1.  **State Management (`src/state/layers.state.ts`):**
        -   Use `jotai` to define a global atom `layersConfigAtom`.
        -   Store configuration for both layers: visible, fillColor, pointRadius, fillMode, fillAttribute.

    2.  **UI Component (`src/components/LayerControl.tsx`):**
        -   Create a collapsible sidebar using Material UI.
        -   **Retail Layer Controls:** Visibility, Color Picker, Radius, "Fill Mode" toggle.
        -   **Sociodemographics Layer Controls:** Visibility, Color Picker, "Fill Mode" toggle.

    3.  **Integration:**
        -   Update `useCartoLayers.ts` to read from `layersConfigAtom`.
        -   Ensure `updateTriggers` are set correctly in Deck.gl.

    **Output:**
    Provide the TypeScript code for the state atom and the `LayerControl` component.
    ```
* **Sub-prompts used (in Cursor):** Performance checks, code structure improvements.

### 5. Advanced Data-Driven Styling
**Goal:** Add extended functionality to control UI visuals with additional logic (Fill by Value).
* **System Prompt used:**
    ```text
    Act as a Senior Cartography Engineer.

    **Objective:**
    Execute Phase 3: "Advanced Data-Driven Styling".

    **Context:**
    We need to implement dynamic coloring based on data attributes.

    **Task:**
    1.  **Refactor `src/hooks/useCartoLayers.ts`:**
        -   Import `colorBins` from `@deck.gl/carto`.
        -   Define `COLOR_SCALES` for Revenue ('PurpOr') and Population ('Mint').

    2.  **Implementation Logic:**
        -   If `config.fillMode === 'byValue'`, replace static color with `colorBins`.
        -   **Crucial:** Update `updateTriggers` to include `fillMode` and `fillAttribute`.

    **Output:**
    Provide the updated code for `useCartoLayers.ts` focusing on the `getFillColor` logic.
    ```
* **Sub-prompts used (in Cursor):** UX improvements and legend synchronization.

### 6. Widget Implementation (Bonus Track)
**Goal:** Implement reactive widgets that read data from the map.
* **Approach:** Implemented two distinct strategies: SQL-based aggregation (Retail) and Viewport-based client-side aggregation (Sociodemographics).
* **Sub-prompts used (in Cursor):**
    * *SQL Widget:* "Create a Histogram component that queries the CARTO SQL API using the active layer's table name."
    * *Viewport Widget:* "Refactor `useViewportStats` to use CPU-side tile aggregation to prevent GPU-readback freezing."

### 7. Refactoring & Documentation
**Goal:** Align TODOs, comments, and prepare Markdown documentation.

---

## Human vs. AI Contribution

* **100% Human:**
    * Initial project setup (Vite, TypeScript configuration).
    * Selection of libraries (Jotai, Material UI).
    * Debugging integration issues (e.g., verifying API tokens).
    * Final design decisions (Layout, Widget positioning).
    * **Prompt Engineering:** Crafting the specific constraints for the AI.

* **AI Generated:**
    * Complex boilerplate (e.g., `VectorTileLayer` configurations).
    * Mathematical logic for Color Scales and interpolations.
    * SQL query construction for the Histogram widget.
    * TypeScript interface definitions.

## Conclusion
This workflow allowed me to focus on **System Design** and **User Experience** while offloading the implementation details to the AI. The result is a robust, well-architected application built in a fraction of the standard development time.